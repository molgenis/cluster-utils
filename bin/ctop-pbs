#!/usr/bin/env perl

# ============================================================================
#  This is ctop copyright 2014 University Medical Center Groningen.
#  Partially based on pbstop copyright 2002, 2003, 2004 University of Southern California.
#      http://www-rcf.usc.edu/~garrick/perl-PBS
#      Please send comments to garrick@usc.edu.
#      Site appears to be down...
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
#  See the GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# ============================================================================

#
# Configurable defaults.
#
# Don't change the defaults here.
# Make a config file instead; see ctop(1).
#
my $columns            = 46;       # Columns in grid
my $sleeptime          = 30;       # Seconds between refreshes
my $colorize           = 1;        # 1 or 0
my $color_by           = 'job';    # Assign color per job, user, queue or resources.
my $show_summary       = 1;        # 1 or 0
my $show_grid          = 1;        # 1 or 0
my $show_queue         = 1;        # 1 or 0
my $show_qqueue        = 1;        # 1 or 0
my $show_jobs          = 1;        # 1 or 0
my $show_user          = 'all';    # Show only jobs for specific users.
my $show_node          = 'all';    # Show only jobs for specific nodes jobs.
my $show_job_id        = 'all';    # Show only jobs with specific job IDs.
my @show_cpu           = ("0");    # List of cpu numbers. No longer used and hardcoded to CPU0.
my @host               = ();       # Hostname of your scheduler
                                   # This is not necessarily the same as the user interface (UI) host
                                   # on which you login to monitor/submit jobs. When empty we will try
                                   # $ENV{"PBS_DEFAULT"}, SERVERHOST from showconfig or localhost.
my $maxrows            = 3000;     # maximum number of rows.
my $maxcolumns         = 137;      # maximum number of columns to start with. 
                                   # May be increased on the fly when the job ID values are too long to fit within the default term width.
my $healthy_load_stdev = 3;        # When node load is lower or higher than requested/allocated cores Â± this stdev 
                                   # it is condidered inefficient or dangerous, respectively.
my $res_usage_low      = 0.80;     # When (usage / requested) resources drops below this threshold it is considered inefficient.
my $res_usage_high     = 1.05;     # When (usage / requested) resources exceeds this threshold it is considered dangerous.

my $qmgr     = "/usr/local/pbs/bin/qmgr";
my $qstat    = "/usr/local/pbs/bin/qstat";

#########################################################
#   Nothing else to adjust below here
#########################################################

use strict;
use warnings;
use vars qw/$VERSION/;
use Curses;

$VERSION = "5.5.4";

#
# Initialize global vars.
#
my %job_of_letter;
my @colors = ();

#
# Define which characters can be used to show jobs or node state in grid view.
# Characters used to indicate state must not be used as masterletters for jobs.
#
my %state_characters = (
	unknown => '?',
	busy    => '@',
	down    => 'X',
	idle    => '.',
	offline => '0',
	other   => '!'
);
#my $masterletters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
my $masterletters = "ABCDEHIKLNOSTUVYZabcdeiklnopqsuvwxyz-+=<>|/\_~";
my $letters       = $masterletters;
my $underline     = 0;

#
# Coordinates.
#
#             y             x: Offset of where last print statement started on main pad. 
#                              Needs increment before adding additional characters to display.
#             Y             X: Height and width of terminal window. May be smaller than main pad.
#     partial_y     partial_x: Top-left coordinate of the part of the main pad currently displayed in the terminal window.
#        last_y        last_x: Last printed character / bottom right coordinate on main pad.
#          subY          subX: Height and width of sub pad.
# sub_partial_y sub_partial_x: Top-left coordinate of the part of the sub pad currently displayed in the sub pad.
#    sub_last_y    sub_last_x: Last printed character / bottom right coordinate on sub pad.
#
my ($y, $x, $Y, $X, $partial_y, $partial_x, $last_y, $last_x, $sub_Y, $sub_X, $sub_partial_y, $sub_partial_x, $sub_last_y, $sub_last_x) = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

_LoadConfig("/etc/ctoprc");
_LoadConfig("$ENV{HOME}/.ctoprc");

#
# Configure and find commandline utils.
#
-e $qmgr     or chomp($qmgr     = `which qmgr 2>/dev/null`);
-e $qmgr     or die "FATAL: Cannot find qmgr.\n";
-e $qstat    or chomp($qstat    = `which wqstat 2>/dev/null`);
-e $qstat    or chomp($qstat    = `which qstat 2>/dev/null`);
-e $qstat    or die "FATAL: Cannot find (w)qstat.\n";

#
#  Process commandline arguments.
#
my @argvhosts = ();
while (my $arg = shift @ARGV) {
	if ($arg eq '-u') {
		if (defined $ARGV[0] and $ARGV[0] =~ /^([^-]+)/) {
			$show_user = join(' ', split(',', shift));
		} else {
			_Usage();
			exit(1);
		}
	} elsif ($arg eq '-n') {
		if (defined $ARGV[0] and $ARGV[0] =~ /^([^-]+)/) {
			$show_node = join(' ', split(',', shift));
		} else {
			_Usage();
			exit(1);
		}
	} elsif ($arg eq '-c') {
		if (defined $ARGV[0] and $ARGV[0] =~ /((job)|(user)|(queue)|(resources))/) {
			$color_by = $1;
		} else {
			_Usage();
			exit(1);
		}
	} elsif ($arg eq '-C') {
		$colorize = !$colorize;
	} elsif ($arg eq '-S') {
		$show_summary = !$show_summary;
	} elsif ($arg eq '-G') {
		$show_grid = !$show_grid;
	} elsif ($arg eq '-Q') {
		$show_queue = !$show_queue;
	} elsif ($arg eq '-t') {
		$show_qqueue = !$show_qqueue;
	} elsif ($arg eq '-j') {
		$show_jobs = !$show_jobs;
	} elsif ($arg eq '-s') {
		$sleeptime = shift @ARGV;
		unless ($sleeptime =~ /^\d+$/ && $sleeptime > 0) {
			_Usage();
			exit(1);
		}
	} elsif ($arg eq '-w') {
		$columns = shift @ARGV;
		unless ($columns =~ /^\d+$/ && $columns > 0) {
			_Usage();
			exit(1);
		}
#	} elsif ($arg =~ /^-(\d+)$/) {
#		@show_cpu = split(//, $1);
	} elsif ($arg =~ /^@(.*)/) {
		push(@argvhosts, $1);
	} elsif ($arg eq '-V') {
		print "ctop $VERSION\n";
		exit(0);
	} elsif ($arg eq '-h') {
		_Usage();
		exit(0);
	} else {
		_Usage();
		exit(1);
	}
}

if (scalar @argvhosts > 0) {
	@host = @argvhosts;
}
undef @argvhosts;

#
# If the scheduler a.k.a. PBS server was not specified,
# try to get it's name from the evironment, defaults or localhost.
#
unless (defined($host[0])) {
	if (defined($ENV{"PBS_DEFAULT"})) {
		$host[0] = $ENV{"PBS_DEFAULT"};
	} elsif (`showconfig | fgrep SERVERHOST` =~ m/SERVERHOST\s+([^\s]+)/) {
		$host[0] = $1;
	} else {
		$host[0] = `hostname`;
	}
}
chomp(@host);

if ($show_job_id eq "all") {
	$show_job_id = 0;
}
if ($show_user eq "all") {
	$show_user = 0;
} elsif ($show_user =~ /\bme\b/) {
	$show_user =~ s/\bme\b/$ENV{USER}/;
}
if ($show_node eq "all") {
	$show_node = 0;
}

use vars qw/$SIGWINCH/;
$SIGWINCH = 0;
$SIG{'WINCH'} = sub { $SIGWINCH = 1; };
$SIG{'INT'}  = sub { endwin; exit(0); };
$SIG{'TERM'} = sub { endwin; exit(0); };

# TODO: Can someone tell me how to use filter() correctly?
-t STDOUT or filter();

#
# TODO: check if definition of control characters like this is portable.
#
my $CTRL_B = chr(ord("B") - ord("@"));
my $CTRL_F = chr(ord("F") - ord("@"));
my $CTRL_L = chr(ord("L") - ord("@"));
my $CTRL_G = chr(ord("G") - ord("@"));
my $CTRL_H = chr(ord("H") - ord("@"));

initscr;
cbreak;
noecho;
getmaxyx($Y, $X);
start_color;
$colorize = $colorize && has_colors();

my $pr = 0;

#
# Every possible color combo is listed below.
# Color pairs that don't look very good are commented out.
# If your eyes disagree with my eyes, you are free to play around with this list.
# Note: only the first $COLOR_PAIRS uncommented combos apply.
# $COLOR_PAIRS is set by your curses implementation.
# The help screen (hit 'h' in ctop) will tell you the value of $COLOR_PAIRS.
#
init_pair(++$pr, COLOR_RED,     COLOR_BLACK);
init_pair(++$pr, COLOR_GREEN,   COLOR_BLACK);
init_pair(++$pr, COLOR_YELLOW,  COLOR_BLACK);
init_pair(++$pr, COLOR_BLUE,    COLOR_BLACK);
init_pair(++$pr, COLOR_MAGENTA, COLOR_BLACK);
init_pair(++$pr, COLOR_CYAN,    COLOR_BLACK);
init_pair(++$pr, COLOR_WHITE,   COLOR_BLACK);

#init_pair( ++$pr, COLOR_BLACK,   COLOR_BLACK );
#init_pair( ++$pr, COLOR_RED,     COLOR_WHITE );
#init_pair( ++$pr, COLOR_GREEN,   COLOR_WHITE );
#init_pair( ++$pr, COLOR_YELLOW,  COLOR_WHITE );
#init_pair( ++$pr, COLOR_BLUE,    COLOR_WHITE );
#init_pair( ++$pr, COLOR_MAGENTA, COLOR_WHITE );
#init_pair( ++$pr, COLOR_CYAN,    COLOR_WHITE );
#init_pair( ++$pr, COLOR_WHITE,   COLOR_WHITE );
init_pair(++$pr, COLOR_BLACK, COLOR_WHITE);

#init_pair( ++$pr, COLOR_RED,     COLOR_YELLOW );
#init_pair( ++$pr, COLOR_GREEN,   COLOR_YELLOW );
#init_pair( ++$pr, COLOR_YELLOW,  COLOR_YELLOW );
#init_pair( ++$pr, COLOR_BLUE,    COLOR_YELLOW );
init_pair(++$pr, COLOR_MAGENTA, COLOR_YELLOW);

#init_pair( ++$pr, COLOR_CYAN,    COLOR_YELLOW );
#init_pair( ++$pr, COLOR_WHITE,   COLOR_YELLOW );
#init_pair( ++$pr, COLOR_BLACK,   COLOR_YELLOW );
init_pair(++$pr, COLOR_RED, COLOR_CYAN);

#init_pair( ++$pr, COLOR_GREEN,   COLOR_CYAN );
init_pair(++$pr, COLOR_YELLOW, COLOR_CYAN);

#init_pair( ++$pr, COLOR_BLUE,    COLOR_CYAN );
init_pair(++$pr, COLOR_MAGENTA, COLOR_CYAN);

#init_pair( ++$pr, COLOR_CYAN,    COLOR_CYAN );
init_pair(++$pr, COLOR_WHITE,  COLOR_CYAN);
init_pair(++$pr, COLOR_BLACK,  COLOR_CYAN);
init_pair(++$pr, COLOR_RED,    COLOR_MAGENTA);
init_pair(++$pr, COLOR_GREEN,  COLOR_MAGENTA);    # current 16th
init_pair(++$pr, COLOR_YELLOW, COLOR_MAGENTA);
init_pair(++$pr, COLOR_BLUE,   COLOR_MAGENTA);

#init_pair( ++$pr, COLOR_MAGENTA, COLOR_MAGENTA );
init_pair(++$pr, COLOR_CYAN,  COLOR_MAGENTA);
init_pair(++$pr, COLOR_WHITE, COLOR_MAGENTA);

#init_pair( ++$pr, COLOR_BLACK,   COLOR_MAGENTA );
#init_pair( ++$pr, COLOR_RED,     COLOR_RED );
init_pair(++$pr, COLOR_GREEN,   COLOR_RED);
init_pair(++$pr, COLOR_YELLOW,  COLOR_RED);
init_pair(++$pr, COLOR_BLUE,    COLOR_RED);
init_pair(++$pr, COLOR_MAGENTA, COLOR_RED);
init_pair(++$pr, COLOR_CYAN,    COLOR_RED);
init_pair(++$pr, COLOR_WHITE,   COLOR_RED);
init_pair(++$pr, COLOR_BLACK,   COLOR_RED);
init_pair(++$pr, COLOR_RED,     COLOR_GREEN);

#init_pair( ++$pr, COLOR_GREEN,   COLOR_GREEN );
#init_pair( ++$pr, COLOR_YELLOW,  COLOR_GREEN );
init_pair(++$pr, COLOR_BLUE, COLOR_GREEN);

#init_pair( ++$pr, COLOR_MAGENTA, COLOR_GREEN );
init_pair(++$pr, COLOR_CYAN,  COLOR_GREEN);
init_pair(++$pr, COLOR_WHITE, COLOR_GREEN);
init_pair(++$pr, COLOR_BLACK, COLOR_GREEN);

my %resource_usage_state_colors = (
	'<' => 3,
	'=' => 2,
	'>' => 1
);

my $pad = newpad($maxrows, $maxcolumns);
my $cmdwin = newwin(1, $X - 1, $Y - 1, 0);
keypad($cmdwin, 1);
my $subpad = 0;
my $subpad_box = 0;
my $subpad_content = 0;
my $helpwin = 0;

_MainLoop(\@host);

#   The original color set.
#        "\033[07;34m",    "\033[07;35m",    "\033[07;36m",
#        "\033[07;37m",    "\033[01;37m",    "\033[35m",
#        "\033[36m",       "\033[37m",       "\033[34m",
#        "\033[33m",       "\033[32m",       "\033[01;36;45m",
#        "\033[01;30;47m", "\033[01;30;46m", "\033[36;45m",
#        "\033[30;47m",    "\033[30;46m",    "\033[01;33m",
#        "\033[01;34m",    "\033[01;35m",    "\033[01;36m",
#        "\033[01;31m",    "\033[01;32m",

###############################################################
## All subroutines below here
###############################################################

# _MainLoop() will 1) gather all of our data from pbs_server, 2) prep it a bit
# in _Letterize() and _Colorize(), 3) call _UpdateDisplay to draw our pretty
# grids and stuff, and finally calls 4) _TopSleep which is where we spend most
# of our time.

# 1) We gather data by parsing the output of tools like qmgr and qstat.
#    Since this data is kept between cycles around the main loop, we take some care to remove old data.
#    The result is two large structures, one for Jobs and one for Nodes, which are used in the rest of the program.

# 2) _Letterize() and _Colorize() are fairly unexciting,
#    but they do assign letters and colors to each running job.
#    This info is stored in the large Job structure.
#    _Letterize() has probably the only original code left.

# 3) _UpdateDisplay() calls the functions responsible for the summary, colorful grid, and the job listing at the bottom.
#    _PrintGrid() draws a big colorful grid for each core of each node.

# 4) _TopSleep() is a big mess. It is far too monolithic.
#    If anyone wants chop it up a bit, feel free to send patches!
#    It loops around on user input until the time expires and it is time to return back up to _MainLoop().
#    In the meantime, it does everything the user requests,
#    including griding through the main data structures looking for stuff.
#    All of the code responsible for moving around the giant pad is here.

sub _Usage {
	print "Usage:  ctop [options] [\@host ...]\n";
	print "  Version: $VERSION\n";
	print "  Options: \n";
	print "  -u [user] Show only jobs for a subset of users.\n";
	print "            Comma separated list.\n";
	print "  -n [node] Show only jobs for a subset of nodes.\n";
	print "            Comma separated list.\n";
	print "  -c [type] Color cores in grid display by type.\n";
	print "            Type must be one of 'job', 'node', 'queue' or resources.\n";
	print "  -C        Toggle colorization.\n";
	print "  -S        Toggle state summary display.\n";
	print "  -G        Toggle grid display.\n";
	print "  -Q        Toggle queue display.\n";
	print "  -t        Toggle showing queued jobs in queue display.\n";
	#print "  -[0-9]...  cpu numbers for grid display.\n";
	print "  -j        Toggle jobs in grid display.\n";
	print "  -s [0-9]+ Seconds between refreshes.\n";
	print "  -w [0-9]+ With of grid in number of cores to display.\n";
	print "  -V        Print version and exit.\n";
	print "  -h        Print this help and exit.\n";
}

sub _MainLoop {
	my $host = shift;
	my %nodes;
	my %jobs;
	my %users;
	my %queues;
	my %state_count;
	my %max_length;
	
	$state_count{'_nodes'}  = 0;
	$state_count{'_anodes'} = 0;
	$state_count{'_procs'}  = 0;
	$state_count{'_aprocs'} = 0;
	$state_count{'_mprocs'} = 0;
	$state_count{'_rjobs'}  = 0;
	$state_count{'_njobs'}  = 0;

	while (1) {
		
		#
		# Reset state counts.
		#
		foreach my $state (keys(%state_count)) {
			$state_count{$state} = 0;
		}
		
		foreach my $server (@$host) {
			#
			# Get updated intel'.
			#
			_GetInfo($server, \%nodes, \%jobs, \%state_count);
			
			#
			# Remove old nodes that are no longer seen.
			#
			foreach my $node (keys(%{$nodes{$server}})) {
				if (!defined($nodes{$server}{$node}{'seen'}) or $nodes{$server}{$node}{'seen'} == 0) {
					delete($nodes{$server}{$node});
				} else {
					$nodes{$server}{$node}{'seen'} = 0;
				}
			}
		}
		
		#
		# Remove old jobs that are no longer seen.
		#
		foreach my $job (keys(%jobs)) {
			if (!defined($jobs{$job}{'seen'}) or $jobs{$job}{'seen'} == 0) {
				my $deleted = delete($jobs{$job});
			} else {
				$jobs{$job}{'seen'} = 0;
			}
		}
		
		#
		# Add derived data for jobs and nodes.
		# Assign characters and color pairs to jobs, users and queues.
		#
		_SupplementInfo(\%nodes, \%jobs);
		_Letterize(\%jobs);
		_Colorize(\%jobs, \%users, \%queues);
		
		#
		# Determine max length of certain names, 
		# so we can adjust column widths accordingly.
		#
		($max_length{'server'}) = _GetMaxKeyLength(\%nodes);
		$max_length{'node'} = 0;
		foreach my $server (keys(%nodes)) {
			my ($max_node_length_for_this_server) = _GetMaxKeyLength($nodes{$server});
			$max_length{'node'} = 
			    $max_node_length_for_this_server > $max_length{'node'}
			  ? $max_node_length_for_this_server
			  : $max_length{'node'};
		}
		$max_length{'job_ID'} = _GetMaxKeyLength(\%jobs);
		
		#
		# Width of server and node columns must be at least as long as their column labels: 'scheduler'(9) and 'node'(4.)
		#
		$max_length{'server'} = $max_length{'server'} > 9 ? $max_length{'server'} : 9;
		$max_length{'node'}   = $max_length{'node'}   > 4 ? $max_length{'node'}   : 4;
		$max_length{'job_ID'} = $max_length{'job_ID'} > 5 ? $max_length{'job_ID'} : 5;
		
		#
		# Get max length of several values and adjust pad width if necessary.
		#
		my $invariable_width = 23; # for the grid display.
		my $grid_width = (($columns - 1) * 2) + (int($columns / 10) * 2);
		if ($invariable_width + $max_length{'server'} + $max_length{'node'} + $grid_width > $maxcolumns) {
			$maxcolumns = $invariable_width + $max_length{'server'} + $max_length{'node'} + $grid_width;
			resize($pad, $maxrows, $maxcolumns);
		}
		$invariable_width = 131; # for the queue display.
		if ($invariable_width + $max_length{'job_ID'} > $maxcolumns) {
			$maxcolumns = $invariable_width + $max_length{'job_ID'};
			resize($pad, $maxrows, $maxcolumns);
		}
		
		_UpdateDisplay(\%state_count, \%max_length, \%nodes, \%jobs, \%users, \%queues);
		-t STDOUT or do { endwin; exit; };
		_TopSleep(\%state_count, \%max_length, \%nodes, \%jobs, \%users, \%queues);
	}
}

sub _GetInfo {
	
	my ($server, $nodes, $jobs, $state_count) = @_;
	
	#
	# Use qmgr and qstat commands to get all data.
	#
	my @qmgr = `$qmgr -c 'l n \@$server' $server 2>/dev/null`;
	$? and do { _PrintWarning("Connection to $server failed.") };
	
	my @qstat = `$qstat -ft \@$server 2>/dev/null`;
	$? and do { _PrintWarning("Connection to $server failed.") };
	
	#
	# Parse qmgr output.
	#
	my $active_jobs;
	my $eating_jobs = 0;
	my $status;
	my $statuses;
	my $eating_status = 0;
	my $node         = "";
	
	foreach (@qmgr) {
		chomp;
		
		if (/^Node /) {
			$node = $';
			$node =~ s/^targetgcc//;
			$node =~ s/-mgmt$//;
			$node =~ s/\s//g;
			delete ${$nodes}{$server}{$node};
			${$nodes}{$server}{$node}{'seen'} = 1;
			${$state_count}{'_nodes'}++;
			$eating_jobs   = 0;
			$eating_status = 0;
		} elsif (/\s+np = (.*)/) {
			${$nodes}{$server}{$node}{'np'} = $1;
			${$state_count}{'_procs'} += $1;
			${$state_count}{'_mprocs'} =
			    ${$state_count}{'_mprocs'} > $1
			  ? ${$state_count}{'_mprocs'}
			  : $1;
			$eating_status = 0;
			$eating_jobs   = 0;
		} elsif (/\s+properties = (.*)/) {
			${$nodes}{$server}{$node}{'properties'} = $1;
			$eating_status                         = 0;
			$eating_jobs                           = 0;
		} elsif (/\s+ntype = (.*)/) {
			${$nodes}{$server}{$node}{'ntype'} = $1;
			$eating_status                    = 0;
			$eating_jobs                      = 0;
		} elsif (/\s+state = (.*)/) {
			${$nodes}{$server}{$node}{'state'} = $1;
			${$state_count}{$1}++;
			$eating_status = 0;
			$eating_jobs   = 0;
		} elsif (/\s+jobs = (.*)/) {
			$eating_jobs   = 1;
			$eating_status = 0;
			$active_jobs   = $1;
			${$state_count}{'_anodes'}++;
			
			#
			# Reset list of jobs on this node.
			#
			${$nodes}{$server}{$node}{'jobs'} = {};
			foreach my $job_slot (split(/, /, $active_jobs)) {
				if ($job_slot =~ m/(\d+)\/(\d+(\[\d+\])?)/) {
					my $slot   = $1;
					my $job_id = $2;
					${$nodes}{$server}{$node}{'job'}{$slot} = $job_id;
					${$state_count}{'_aprocs'}++;
					if (defined(${$nodes}{$server}{$node}{'jobs'}{$job_id})) {
						${$nodes}{$server}{$node}{'jobs'}{$job_id}++;
					} else {
						${$nodes}{$server}{$node}{'jobs'}{$job_id} = 1;
					}
				} else {
					_PrintWarning("ERROR: Cannot parse job ID from job slot $job_slot.");
				}
			}
		} elsif (/\s+status = (.*)/) {
			$eating_status = 1;
			$eating_jobs   = 0;
			$statuses     = $1;
			foreach my $status (split(/,/, $statuses)) {
				if ($status =~ m{(.+)=(.+)}) {
					${$nodes}{$server}{$node}{'status'}{$1} = $2;
				}
			}
		} elsif ($eating_jobs) {
			if ($_ =~ /\w/) {
				/^\s+(.*)$/;
				$active_jobs = $1;
				foreach my $job_slot (split(/, /, $active_jobs)) {
					if ($job_slot =~ m/(\d+)\/(\d+(\[\d+\])?)/) {
						my $slot   = $1;
						my $job_id = $2;
						${$nodes}{$server}{$node}{'job'}{$slot} = $job_id;
						${$state_count}{'_aprocs'}++;
						if (defined(${$nodes}{$server}{$node}{'jobs'}{$job_id})) {
							${$nodes}{$server}{$node}{'jobs'}{$job_id}++;
						} else {
							${$nodes}{$server}{$node}{'jobs'}{$job_id} = 1;
						}
					} else {
						_PrintWarning("ERROR: Cannot parse job ID from job slot $job_slot.");
					}
				}
			} else {
				$eating_jobs = 0;
			}
		} elsif ($eating_status) {
			if ($_ =~ /\w/) {
				/^\s+(.*)$/;
				$statuses = $1;
				foreach my $status (split(/,/, $statuses)) {
					if ($status =~ m{(.+)=(.+)}) {
						${$nodes}{$server}{$node}{'status'}{$1} = $2;
					}
				}
			} else {
				$eating_status = 0;
			}
		}
	}
	
	#
	# Parse qstat output.
	#
	my $job;
	
	foreach (@qstat) {
		chomp;
		if (/^\s*Job Id: /i) {
			if (/^\s*Job Id: ([0-9]+(\[[0-9]+\])?)\.([a-z0-9A-Z\-\._]+)/) {
				$job = $1;
				my $scheduler = $3;
				if ($server eq $scheduler) {
					${$jobs}{$job}{'seen'}   = 1;
					${$jobs}{$job}{'server'} = $server;
					${$state_count}{'_njobs'}++;
				} else {
					die 'FATAL: server reported in qstat output (' . $scheduler . ') does not match server for which info was requested (' . $server . ').';
				}
			} else {
				die 'FATAL: cannot parse JobID from qstat output line: ' . $_;
			}
		} elsif (/^\s*Job_Name = (.+)/i) {
			${$jobs}{$job}{'jname'} = $1;
		} elsif (/^\s*Job_Owner = ([^@]+)/i) {
			${$jobs}{$job}{'user'} = $1;
		} elsif (/^\s*job_state = ([CEHQRSTW])/i) {
			my $state = $1;
			${$jobs}{$job}{'state'} = $state;
			if ($state eq 'R') {
				${$state_count}{'_rjobs'}++;
			}
		} elsif (/^\s*queue = (.+)/i) {
			${$jobs}{$job}{'queue'} = $1;
		} elsif (/^\s*Resource_List.nodes = ([1-9][0-9]*):ppn=([1-9][0-9]*)/i) {
			${$jobs}{$job}{'ncount'}  = $1;
			${$jobs}{$job}{'cores_r'} = $2 * $1;
		} elsif (/^\s*Resource_List.nodes = ([1-9][0-9]*)$/i) {
			${$jobs}{$job}{'ncount'}  = $1;
			${$jobs}{$job}{'cores_r'} = 1 * $1; # no cores were specified -> defaults to 1. 
		} elsif (/^\s*Resource_List.(p?mem) = ([0-9]+)([a-z]+)$/i) {
			my $mem_type  = $1; # either mem (total) or pmem (per core).
			my $mem_value = $2;
			my $mem_unit  = $3;
			if ($mem_unit eq 'b') {
				$mem_value = $mem_value / 1073741824;
			} elsif ($mem_unit eq 'kb') {
				$mem_value = $mem_value / 1048576;
			} elsif ($mem_unit eq 'mb') {
				$mem_value = $mem_value / 1024;
			} elsif ($mem_unit eq 'gb') {
				$mem_value = $mem_value;
			} else {
				die "FATAL: Unsupported mem unit $mem_unit in $qstat -f output.";
			}
			${$jobs}{$job}{$mem_type . '_r'} = sprintf("%.1f", $mem_value);
		} elsif (/^\s*Resource_List.walltime = ([0-9:]+)/i) {
			${$jobs}{$job}{'walltime_r'} = $1;
		} elsif (/^\s*resources_used.cput = (.+)$/i) {
			${$jobs}{$job}{'cputime_u'} = $1;
		} elsif (/^\s*resources_used.mem = ([0-9]+)([a-z]+)$/i) {
			my $mem_value = $1;
			my $mem_unit  = $2;
			if ($mem_unit eq 'b') {
				$mem_value = $mem_value / 1073741824;
			} elsif ($mem_unit eq 'kb') {
				$mem_value = $mem_value / 1048576;
			} elsif ($mem_unit eq 'mb') {
				$mem_value = $mem_value / 1024;
			} elsif ($mem_unit eq 'gb') {
				$mem_value = $mem_value;
			} else {
				die "FATAL: Unsupported mem unit $mem_unit in $qstat -f output.";
			}
			${$jobs}{$job}{'mem_u'} = sprintf("%.1f", $mem_value);
		} elsif (/^\s*resources_used.walltime = (.+)/i) {
			${$jobs}{$job}{'walltime_u'} = $1;
		}
	}
}

sub _SupplementInfo {
	
	my ($nodes, $jobs) = @_;
	
	#
	# Revisit info about all jobs and 
	#  * add defaults for required data if missing.
	#  * calculate derived data.
	#
	foreach my $job (keys(%{$jobs})) {
		foreach my $attribute ('server','jname','user','queue','state') {
			unless (defined(${$jobs}{$job}{$attribute})) {
				${$jobs}{$job}{$attribute} = '?';
				_PrintWarning('ERROR: Missing required attribute ' . $attribute . ' for job ' . $job);
			}
		}
		if (defined(${$jobs}{$job}{'cputime_u'}) && defined(${$jobs}{$job}{'walltime_u'})) {
			my @cputime = reverse(split(':', ${$jobs}{$job}{'cputime_u'}));
			my $cputime_sec = $cputime[0] + ($cputime[1] * 60) + ($cputime[2] * 3600);
			my @walltime = reverse(split(':', ${$jobs}{$job}{'walltime_u'}));
			my $walltime_sec = $walltime[0] + ($walltime[1] * 60) + ($walltime[2] * 3600);
			if ($walltime_sec > 0) {
				${$jobs}{$job}{'cpu_u'} = sprintf("%u", ($cputime_sec / $walltime_sec) * 100);
			}
			#_PrintWarning("DEBUG: walltime_sec = $walltime[0] | $walltime[1] | $walltime[2]");
			#_PrintWarning("DEBUG: cputime = ${$jobs}{$job}{cputime_u} | walltime = ${$jobs}{$job}{walltime_u} | cputime_sec = $cputime_sec | walltime_sec = $walltime_sec");
		}
		if (defined(${$jobs}{$job}{'cores_r'}) && ${$jobs}{$job}{'cores_r'} > 0) {
			${$jobs}{$job}{'cpu_r'} = ${$jobs}{$job}{'cores_r'} * 100;
		} else {
			${$jobs}{$job}{'cpu_r'} = undef;
		}
		if (defined(${$jobs}{$job}{'cpu_u'} && defined(${$jobs}{$job}{'cpu_r'}))) {
			my $cpu_u = ${$jobs}{$job}{'cpu_u'};
			my $cpu_r = ${$jobs}{$job}{'cpu_r'};
			my $cpu_s; # usage state.
			if (($cpu_u / $cpu_r) < $res_usage_low) {
				$cpu_s = '<';
			} elsif (($cpu_u / $cpu_r) > $res_usage_high) {
				$cpu_s = '>';
			} else {
				$cpu_s = '=';
			}
			${$jobs}{$job}{'cpu_s'} = $cpu_s;
		}
		if (defined(${$jobs}{$job}{'pmem_r'})) {
			if (defined(${$jobs}{$job}{'cores_r'})) {
				my $total_mem = sprintf("%.1f", ${$jobs}{$job}{'pmem_r'} * ${$jobs}{$job}{'cores_r'});
				if (defined(${$jobs}{$job}{'mem_r'})) {
					if (${$jobs}{$job}{'mem_r'} < $total_mem) {
						${$jobs}{$job}{'mem_r'} = $total_mem;
					}
				} else {
					${$jobs}{$job}{'mem_r'} = $total_mem;
				}
			}
		}
		if (!defined(${$jobs}{$job}{'mem_r'}) || ${$jobs}{$job}{'mem_r'} <= 0) {
			${$jobs}{$job}{'mem_r'} = 0.1 # default to low value if not specified to prevent illegal devide by zero errors.
		}
		if (defined(${$jobs}{$job}{'mem_u'}) && defined(${$jobs}{$job}{'mem_r'})) {
			my $mem_u = ${$jobs}{$job}{'mem_u'};
			my $mem_r = ${$jobs}{$job}{'mem_r'};
			my $mem_s; # usage state.
			if (($mem_u / $mem_r) < $res_usage_low) {
				$mem_s = '<';
			} elsif (($mem_u / $mem_r) > $res_usage_high) {
				$mem_s = '>';
			} else {
				$mem_s = '=';
			}
			${$jobs}{$job}{'mem_s'} = $mem_s;
		}
	}
	
	#
	# Revisit info about all nodes and copy some details to the data structure indexed by job.
	#
	foreach my $server (keys(%{$nodes})) {
		foreach my $node (keys(%{${$nodes}{$server}})) {
			foreach my $job (keys(%{${$nodes}{$server}{$node}{jobs}})) {
				if (defined(${$jobs}{$job})) {
					if (${$jobs}{$job}{'server'} eq $server) {
						${$jobs}{$job}{'node'}    = $node;
						${$jobs}{$job}{'cores_u'} = ${$nodes}{$server}{$node}{'jobs'}{$job};
					} else {
						_PrintWarning("ERROR: Scheduler does not match for job ID ${job} (nodes server = $server but jobs server = ${$jobs}{$job}{server}).");
					}
				} else {
					_PrintWarning("ERROR: Cannot find job ID ${job} in list of jobs.");
				}
			}
		}
	}
}

sub _UpdateDisplay {
	
	my ($state_count, $max_length, $nodes, $jobs, $users, $queues) = @_;
	
	my $foo;
	move($pad, 0, 0);
	getmaxyx($Y, $X);
	$y = 0, $x = 0;
	
	$show_summary and _PrintStateSummary($state_count);
	$show_grid    and _PrintGrid($jobs, $nodes, $users, $queues, $max_length);
	$show_queue   and _PrintQueue($jobs, $users, $queues, $max_length);
	
	getyx($pad, $last_y, $foo);
	clrtobot($pad);
	
	pnoutrefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
	mvwin($cmdwin, $Y - 1, 0);
	refresh($cmdwin);
	_UpdateSubWindow(@_);
}

#
# Print summary state of entire cluster.
#
sub _PrintStateSummary {
	
	my ($state_count) = @_;
	
	#
	# Usage summary.
	#
	addstr($pad, sprintf("Usage Totals: %d/%d %s | %d/%d %s | %d/%d %s", 
		${$state_count}{'_aprocs'}, ${$state_count}{'_procs'}, 'Cores', 
		${$state_count}{'_anodes'}, ${$state_count}{'_nodes'}, 'Nodes', 
		${$state_count}{'_rjobs'},  ${$state_count}{'_njobs'}, 'Jobs Running'));
	
	#
	# Show time stamp.
	#
	my ($y1, $x1);
	getyx($pad, $y1, $x1);
	my $max_state_line_length = $X < $maxcolumns ? $X : $maxcolumns;
	addstr($pad, ' ' . ' ' x ($max_state_line_length - $x1 - 23));
	#_PrintWarning("DEBUG: X = $X | Y = $Y | x1 = $x1 | y1 = $y1 | current x = $x | current y = $y");
	#addstr($pad, sprintf("%02d:%02d:%02d", (localtime())[ 2, 1, 0 ]));
	addstr($pad, `date "+%Y-%m-%d-T%H:%M:%S"`);
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
	
	#
	# Show node summary.
	#
	my $line;
	my @states = sort(grep(!/^_/, keys(%{$state_count})));
	addstr($pad, 1, 0, 'Node States:');
	for (my $i = 0 ; defined($states[$i]) ; $i++) {
		$line = ' ' . ${$state_count}{$states[$i]} . ' ' . $states[$i];
		$line .= defined($states[$i + 1]) ? ' |' : '';
		getyx($pad, $y1, $x1);
		if ($X - $x1 - 1 < length($line)) {
			clrtoeol($pad);
			move($pad, ++$y, $x = 0);
			addstr($pad, ' ' x 12);
		}
		addstr($pad, $line);
	}
	move($pad, ++$y, $x = 0);
	clrtoeol($pad);
}

sub _PrintGrid {
	
	my ($jobs, $nodes, $users, $queues, $max_length) = @_;
	
	$last_x = 0;
	
	#
	# Keep track of columns.
	#  * Column 0 contains the node name.
	#  * Column 1 - ... contains the cores / job slots on that node.
	#
	my $col = 0;
	my $headerspaces = 1;
	
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
	
	if (!scalar @show_cpu) {
		#addstr($pad, "  No CPUs selected!");
		#clrtoeol($pad);
		#return;
		$show_cpu[0] = "0";
	}
	
	#_PrintVcpuLine($max_length);
	
	foreach my $server (sort(keys(%{$nodes}))) {
		
		_PrintNumberLine($max_length, $headerspaces, $columns);
		
		foreach my $node (sort(keys(%{${$nodes}{$server}}))) {
			
			unless ($show_node ? $show_node =~ /\b$node\b/ : 1) {
				next;
			}
			
			_PrintDashLine($max_length, $headerspaces, $columns);
			my $col = 0;
			my $load =
			  defined($$nodes{$server}{$node}{status}{'loadave'})
			  ? $$nodes{$server}{$node}{status}{'loadave'}
			  : '?';
			my $node_state      = $$nodes{$server}{$node}{'state'};
			my $available_cores = $$nodes{$server}{$node}{np};
			my $used_cores      = 0;
			
			#
			# Grid display sorted by job.
			#
			JOB: foreach my $job (sort(keys(%{${$nodes}{$server}{$node}{jobs}}))) {
				
				my $letter    = 0;
				my $color     = 0;
				my $underline = 0;
				my $cpu_state = 'busy';
				
				#
				# Sanity checks on presense of data.
				#
				unless (defined(${$jobs}{$job})) {
					_PrintWarning('WARN: Job ' . $job . ' was seen running on a node, but missing from qstat output. (May be sync issue.)');
					next JOB;
				}
				unless (    defined(${$jobs}{$job}{user})
						and defined(${$jobs}{$job}{node})) {
					_PrintWarning('WARN: Job ' . $job . ' was seen running on a node, but is lacking user or node info in qstat output.');
					next JOB;
				}
				
				#
				# Check if we need to display or skip this job.
				#
				unless (    ($show_user     ? $show_user     =~ /\b$$jobs{$job}{user}\b/ : 1)
						and ($show_node     ? $show_node     =~ /\b$$jobs{$job}{node}\b/ : 1)
						and ($show_job_id   ? $show_job_id   =~ m/\b$job\b/ : 1)
					   ) {
					next JOB;
				}
					
				#
				# Get job details.
				# By default color by job.
				#
				unless (    defined(${$jobs}{$job}{letter})
						and defined(${$jobs}{$job}{color})
						and defined(${$jobs}{$job}{underline})
						and defined(${$jobs}{$job}{queue})) {
					_PrintWarning('WARN: Job ' . $job . ' was seen running on a node, but is lacking details (letter, color, underline or queue).');
				}
				$letter    = ${$jobs}{$job}{letter};
				$color     = ${$jobs}{$job}{color};
				$underline = ${$jobs}{$job}{underline};
				my $user  = ${$jobs}{$job}{user};
				my $queue = ${$jobs}{$job}{queue};
				
				if ($color_by eq 'user') {
					$color = ${$users}{$user}{color};
				} elsif ($color_by eq 'queue') {
					$color = ${$queues}{$queue}{color};
				} elsif ($color_by eq 'resources') {
					$color = 7; # white on black.
					if (defined(${$jobs}{$job}{cpu_s}) && defined(${$jobs}{$job}{mem_s})) {
						my $cpu_s = ${$jobs}{$job}{cpu_s};
						my $mem_s = ${$jobs}{$job}{mem_s};
						if ($cpu_s eq '=' && $mem_s eq '=') {
							$color = $resource_usage_state_colors{'='};
						} else {
							if ($cpu_s eq '<' || $mem_s eq '<') {
								$color = $resource_usage_state_colors{'<'};
							}
							if ($cpu_s eq '>' || $mem_s eq '>') {
								$color = $resource_usage_state_colors{'>'};
							}
						}
					}
				}
				
				for (my $slots = 1 ; $slots <= ${$nodes}{$server}{$node}{jobs}{$job} ; $slots++) {
					if ($col >= $columns) {
						move($pad, ++$y, $x = 0);
						$col = 0;
					}
					if ($col == 0) {
						addstr($pad, sprintf "  %${$max_length}{'server'}s %${$max_length}{'node'}s ", $server, $node);
					} elsif ($col != 0 and $col % 10 == 0) {
						addstr($pad, '  ');
					}
					_PrintCoreState($job, $letter, $cpu_state, $color, $underline);
					addstr($pad, ' ');
					clrtoeol($pad);
					$col++;
					$used_cores++;
				}
			}
			
			#
			# When not all cores are used: fill the remaining ones in the grid with the node state.
			#
			my $listed_cores = $used_cores;
			while ($listed_cores < $$nodes{$server}{$node}{np}) {
				if ($col >= $columns) {
					move($pad, ++$y, $x = 0);
					$col = 0;
				}
				if ($col == 0) {
					addstr($pad, sprintf "  %${$max_length}{'server'}s %${$max_length}{'node'}s ", $server, $node);
				} elsif ($col != 0 and $col % 10 == 0) {
					addstr($pad, '  ');
				}
				_PrintCoreState(0, 0, $node_state, 0, 0);
				addstr($pad, ' ');
				$col++;
				$listed_cores++;
				clrtoeol($pad);
			}
			
			while ($col < $columns) {
				addstr($pad, '  ') if ($col != 0 and $col % 10 == 0);
				addstr($pad, '  ');
				$col++;
				clrtoeol($pad);
			}
			
			#
			# Print node load and health.
			# Health will warn if the load is inefficiently low or dangerously high.
			#
			addstr($pad, sprintf "%6s ", $load);
			my $health = '= ? ';
			my $color = 3;
			if ($load =~ m/^(\d*\.)?\d+$/) {
				if ($load < $used_cores - $healthy_load_stdev) {
					$health = '= too low!';
					$color  = 3;
				} elsif ($load > $used_cores + $healthy_load_stdev) {
					$health = '= TOO HIGH!';
					$color = 1;
				} else {
					$health = '= Ok';
					$color = 2;
				}
			}
			$colorize and attron($pad, A_BOLD | COLOR_PAIR($color));
			addstr($pad, $health);
			$colorize and attroff($pad, A_BOLD | COLOR_PAIR($color));
			getyx($pad, my $current_last_y, my $current_last_x);
			$last_x = $last_x > $current_last_x ? $last_x : $current_last_x;
			clrtoeol($pad);
			move($pad, ++$y, $x = 0);
			
			clrtoeol($pad);
			move($pad, ++$y, $x = 0) if $col != $columns;
		}
		
		_PrintDashLine($max_length, 1, $columns);
		
	}
	
	#
	# Print legend underneath grid.
	#
	my $legend = sprintf("  %${$max_length}{'server'}s %${$max_length}{'node'}s ", ' ', ' ');
	$legend .= 'legend:';
	$legend .= " $state_characters{'unknown'} unknown";
	$legend .= " | $state_characters{'busy'} busy";
	$legend .= " | $state_characters{'down'} down";
	$legend .= " | $state_characters{'idle'} idle";
	$legend .= " | $state_characters{'offline'} offline";
	$legend .= " | $state_characters{'other'} other";
	addstr($pad, $y, 0, $legend);
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
	clrtoeol($pad);
	
}

#
# Print the job queue.
#
sub _PrintQueue {
	
	my ($jobs, $users, $queues, $max_length) = @_;
	
	#
	# Get max length of several values and adjust pad width if necessary.
	#
	my $max_job_id_length = ${$max_length}{'job_ID'};
	
	my $format_base     = "%-${max_job_id_length}s %-15.15s %-12.12s %-40.40s %1s";
	my $format_cpu      = " %6.6s";
	my $format_mem      = " %8.8s";
	my $format_walltime = " %9.9s";
	
	move($pad, ++$y, $x = 0);
	attron($pad, A_BOLD);
	addstr($pad, '      ');
	addstr($pad, sprintf($format_base, 'JobID', 'Username', 'Queue', 'Jobname', 'S'));
	addstr($pad, sprintf($format_cpu, 'CPU(%)'));
	addstr($pad, sprintf($format_cpu, 'CPU(%)'));
	addstr($pad, sprintf($format_mem, 'Mem(GiB)'));
	addstr($pad, sprintf($format_mem, 'Mem(GiB)'));
	addstr($pad, sprintf($format_walltime, 'Walltime'));
	addstr($pad, sprintf($format_walltime, 'Walltime'));
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
	addstr($pad, '      ');
	addstr($pad, sprintf($format_base, '', '', '', '', ''));
	addstr($pad, sprintf($format_cpu, '~used'));
	addstr($pad, sprintf($format_cpu, 'req.'));
	addstr($pad, sprintf($format_mem, 'used'));
	addstr($pad, sprintf($format_mem, 'req.'));
	addstr($pad, sprintf($format_walltime, 'used'));
	addstr($pad, sprintf($format_walltime, 'requested'));
	attroff($pad, A_BOLD);
	clrtoeol($pad);
	getyx($pad, my $current_last_y, my $current_last_x);
	$last_x = $last_x > $current_last_x ? $last_x : $current_last_x;
	move($pad, ++$y, $x = 0);
	
	#
	# Note: we never print the server name as we expected users will recognize their jobs by jobID or queue name.
	#
	
	#
	# Print jobs sorted by
	#  1. Server followed by
	#  2. JobID without optional array task suffix followed by
	#  3. opional array task suffix.
	#
	foreach my $job (sort{     (defined(${$jobs}{$a}{'server'}) && defined(${$jobs}{$b}{'server'}) && ${$jobs}{$a}{'server'} cmp ${$jobs}{$b}{'server'})
							or (($a =~ m/^(\d+)/)[0] <=> ($b =~ m/^(\d+)/)[0])
							or ($a =~ m/\[(\d+)\]$/ && $b =~ m/\[(\d+)\]$/ && ($a =~ m/\[(\d+)\]$/)[0] <=> ($b =~ m/\[(\d+)\]$/)[0])
						} keys(%{$jobs})) {
		
		if ($y >= $maxrows ) {
			_PrintWarning('WARN: too many jobs -> queue display truncated. Increase $maxrows or use one of the filter commands.');
			return;
		}
		
		#
		# Get job details required to determine if this job will be displayed or skipped.
		#
		my $user     = ${$jobs}{$job}{'user'};
		my $queue    = ${$jobs}{$job}{'queue'};
		my $state    = ${$jobs}{$job}{'state'};
		my $node     = defined(${$jobs}{$job}{'node'}) ? ${$jobs}{$job}{'node'}  : '-';
		
		#
		# Skip this job if display was not requested.
		#
		next unless ($show_job_id   ? $show_job_id   =~ m/\b$job\b/ : 1);
		next unless ($show_user     ? $show_user     =~ m/\b$user\b/ : 1);
		next unless ($state =~ m/[TREC]/ && $show_node ? $show_node =~ /\b$node\b/ : 1);
		next if ($state =~ m/[^TREC]/ && $show_qqueue == 0);
		
		#
		# Get job details that determine how the job will be displayed. 
		#
		my $job_name  = ${$jobs}{$job}{'jname'};
		my $l         = ${$jobs}{$job}{'letter'};
		my $underline = ${$jobs}{$job}{'underline'};
		my $color     = ${$jobs}{$job}{'color'};
		if ($color_by eq 'user') {
			$color = ${$users}{$user}{'color'};
		} elsif ($color_by eq 'queue') {
			$color = ${$queues}{$queue}{'color'};
		} elsif ($color_by eq 'resources') {
			$color = 7; # white on black.
			if (defined(${$jobs}{$job}{'cpu_s'}) && defined(${$jobs}{$job}{'mem_s'})) {
				my $cpu_s = ${$jobs}{$job}{'cpu_s'};
				my $mem_s = ${$jobs}{$job}{'mem_s'};
				if ($cpu_s eq '=' && $mem_s eq '=') {
					$color = $resource_usage_state_colors{'='};
				} else {
					if ($cpu_s eq '<' || $mem_s eq '<') {
						$color = $resource_usage_state_colors{'<'};
					}
					if ($cpu_s eq '>' || $mem_s eq '>') {
						$color = $resource_usage_state_colors{'>'};
					}
				}
			}
		}
		
		addstr($pad, '  ');
		if (defined($l) and ${$jobs}{$job}{'state'} eq 'R') {
			_PrintColoredLetter($l, $color, $underline);
			addstr($pad, ' = ');
		} else {
			addstr($pad, '    ');
		}
		
		
		#
		# Print base job info.
		#
		addstr($pad, sprintf($format_base, 
			$job, 
			${$jobs}{$job}{'user'}, 
			${$jobs}{$job}{'queue'}, 
			${$jobs}{$job}{'jname'}, 
			${$jobs}{$job}{'state'}
		));
		#_PrintWarning('DEBUG: Job ' . $job .' | user '. ${$jobs}{$job}{'user'} . ' | queue ' . ${$jobs}{$job}{'queue'} . ' | state ' . ${$jobs}{$job}{'state'} . '.');
		
		#
		# Print job's CPU info.
		#
		if (defined(${$jobs}{$job}{'cpu_u'})) {
			my $cpu_u = ${$jobs}{$job}{'cpu_u'};
			if ($colorize && defined(${$jobs}{$job}{'cpu_s'})) {
				my $state = ${$jobs}{$job}{'cpu_s'};
				attron($pad, A_BOLD | COLOR_PAIR($resource_usage_state_colors{$state}));
				addstr($pad, sprintf($format_cpu, $cpu_u));
				attroff($pad, A_BOLD | COLOR_PAIR($resource_usage_state_colors{$state}));
			} else {
				addstr($pad, sprintf($format_cpu, $cpu_u));
			}
		} else {
			addstr($pad, sprintf($format_cpu, ''));
		}
		addstr($pad, sprintf($format_cpu, 
			defined(${$jobs}{$job}{'cpu_r'}) ? ${$jobs}{$job}{'cpu_r'} : ''
		));
		
		#
		# Print job's memory info.
		#
		if (defined(${$jobs}{$job}{'mem_u'})) {
			my $mem_u = ${$jobs}{$job}{'mem_u'};
			if ($colorize && defined(${$jobs}{$job}{'mem_s'})) {
				my $state = ${$jobs}{$job}{'mem_s'};
				attron($pad, A_BOLD | COLOR_PAIR($resource_usage_state_colors{$state}));
				addstr($pad, sprintf($format_mem, $mem_u));
				attroff($pad, A_BOLD | COLOR_PAIR($resource_usage_state_colors{$state}));
			} else {
				addstr($pad, sprintf($format_mem, $mem_u));
			}
		} else {
			addstr($pad, sprintf($format_mem, ''));
		}
		addstr($pad, sprintf($format_mem, 
			defined(${$jobs}{$job}{'mem_r'}) ? ${$jobs}{$job}{'mem_r'} : ''
		));
		
		#
		# Print job's walltime info.
		#
		addstr($pad, sprintf($format_walltime, 
			defined(${$jobs}{$job}{'walltime_u'}) ? ${$jobs}{$job}{'walltime_u'} : ''
		));
		addstr($pad, sprintf($format_walltime, 
			defined(${$jobs}{$job}{'walltime_r'}) ? ${$jobs}{$job}{'walltime_r'} : ''
		));
		
		clrtoeol($pad);
		move($pad, ++$y, $x = 0);
		
	}
	
	clrtoeol($pad);
}

#
# Assign a letter to each job.
#
sub _Letterize {
	
	my ($jobs) = @_;
	
	#
	# %job_of_letter is only used to note the fact that _someone_ is using that letter.
	# If a job gets a letter that is already assigned, 
	# the second one will be noted in %job_of_letter,
	# which is Ok because we don't care _who_ has that letter.
	
	#
	# Remove info about old jobs.
	#
	foreach my $l (keys(%job_of_letter)) {
		my $job_id_of_l = $job_of_letter{$l};
		unless (defined(${$jobs}{$job_id_of_l})) {
			my $deleted = delete($job_of_letter{$l});
		}
	}
	
	#
	# Pick a letter.
	#
	foreach my $job (keys(%{$jobs})) {
		#
		# Skip jobs that already have a letter assigned
		# or that are queued / on hold and do not yet need a letter.
		#
		next unless (defined(${$jobs}{$job}{'state'}));
		next if (${$jobs}{$job}{'state'} =~ m/[HQ]/);
		my $user = ${$jobs}{$job}{'user'};
		unless (defined(${$jobs}{$job}{'letter'})) {
			#
			# Find a letter that isn't already taken.
			#
			my $l = substr($user, 0, 1);
			if (defined($job_of_letter{$l})) {
				$l = uc($l);
				if (defined($job_of_letter{$l})) {
					if (length($letters) <= 0) {
						#
						# Replenish our supply of letters.
						#
						$colorize or _PrintWarning('WARN: Reusing letters on B&W terminal.');
						$letters   = $masterletters;
						$underline = !$underline;
					}
					$letters =~ s/(.)//;
					$l = $1;
				}
			}
			$job_of_letter{$l}          = $job;
			${$jobs}{$job}{'letter'}    = $l;
			${$jobs}{$job}{'underline'} = $underline;
			if ($l =~ m/[^a-zA-Z0-9_]/) {
				$l = '\\' . "$l";
			}
			$letters =~ s/$l//;
		}
	}
}

#
# Assign a color to each job, user and queue.
#
sub _Colorize {
	
	my ($jobs, $users, $queues) = @_;
	
	foreach my $job (keys(%{$jobs})) {
		next if (defined(${$jobs}{$job}{'color'}));
		
		scalar(@colors == 0) and @colors = _InitColors();
		my $color = shift(@colors);
		${$jobs}{$job}{'color'} = $color;
		
		my $user  = ${$jobs}{$job}{'user'};
		my $queue = ${$jobs}{$job}{'queue'};
		${$users}{$user}{'color'}   = $color unless (defined(${$users}{$user}{'color'}));
		${$queues}{$queue}{'color'} = $color unless (defined(${$queues}{$queue}{'color'}));
	}
}

sub _InitColors {
	return (1 .. ($COLOR_PAIRS - 1 > $pr ? $pr : $COLOR_PAIRS - 1));
}

# This sucks, I wanted to seperate printing from colors,
# but I can't just pass back color escape strings.
# I'm forced to combine them here.
sub _PrintColoredLetter {
	my ($letter, $color, $underline) = @_;
	if ($colorize) {
		#_PrintWarning("DEBUG: color = $color");
		attron($pad, A_BOLD | COLOR_PAIR($color) | ($underline && A_UNDERLINE));
		addstr($pad, $letter);
		attroff($pad, A_BOLD | COLOR_PAIR($color) | ($underline && A_UNDERLINE));
	} else {
		addstr($pad, $letter);
	}
}

#
# Used to find the longest hostnames to align the left side of the grid.
#
sub _GetMaxKeyLength {
	my ($hash) = @_;
	my $max_length = 0;
	foreach my $value (keys(%{$hash})) {
		$max_length =
		    length($value) > $max_length
		  ? length($value)
		  : $max_length;
	}
	return($max_length);
}

#
# Prints each character representing each core in the grid.
#
sub _PrintCoreState {
	
	my ($job, $letter, $state, $color, $underline) = @_;
	
	if ($job) {
		unless ($letter) {
			_PrintWarning("WARN: $job has no letter.");
			$letter = $state_characters{'unknown'};
		}
	}
	
	if ($state =~ /down/ and $job) {
		_PrintColoredLetter($letter, $color, $underline);
	} elsif ($job and $show_jobs) {
		_PrintColoredLetter($letter, $color, $underline);
	} elsif ($state =~ /down/) {
		addch($pad, $state_characters{'down'});
	} elsif ($state =~ /offline/) {
		addch($pad, $state_characters{'offline'});
	} elsif ($state =~ /job-exclusive/) {
		addch($pad, $state_characters{'busy'});
	} elsif ($state =~ /busy/) {
		addch($pad, $state_characters{'busy'});
	} elsif ($state =~ /reserve/) {
		addch($pad, $state_characters{'busy'});
	} elsif ($state =~ /unknown/i) {
		addch($pad, $state_characters{'unknown'});
	} elsif ($state =~ /free/) {
		addch($pad, $state_characters{'idle'});
	} else {
		addch($pad, $state_characters{'other'});
	}
}

#
# Print the list of visible CPUs above the grid.
#
sub _PrintVcpuLine {
	
	my ($max_length) = @_;
	
	# inform the user of the visible CPUs.
	if (scalar(@show_cpu) == 1) {
		addstr($pad, "  CPU $show_cpu[0]" . ' ' x (${$max_length}{'server'} + 1 + ${$max_length}{'node'} - 4));
	#} elsif ( scalar @show_cpu == $maxprocs ) {
	#	addstr($pad, '   ' . ' ' x ($maxlen));
	} else {
		addstr($pad, ' ' x ($X - 1));
		move($pad, $y, 0);
		addstr($pad, ' visible CPUs: ' . join(',', @show_cpu));
	}
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
}

#
# Print the line of dashes above and below a node in the grid.
#
sub _PrintDashLine {
	
	my ($max_length, $spaces, $columns) = @_;
	
	my $line = '   ' . ' ' x (${$max_length}{'server'} + 1 + ${$max_length}{'node'});
	for (my $i = 0 ; $i < $columns ; $i++) {
		$line .= '--' if ($i != 0 and $i % 10 == 0);
		$line .= '-' . '-' x $spaces;
	}
	$line =~ s/-$//; # Create one dash too much; delete it.
	addstr($pad, $line);
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
}

#
# Print the line of sequenctial numbers for the cores along the top of the grid.
#
sub _PrintNumberLine {
	
	my ($max_length, $spaces, $columns) = @_;
	
	my $line = '  ' . sprintf("%${$max_length}{'server'}s", 'scheduler') . ' ' . sprintf("%${$max_length}{'node'}s", 'node') . ' ';
	for (my $i = 0, my $j = 0 ; $i < $columns ; $i++, $j++) {
		if ($i != 0 and $i % 10 == 0) {
			$line .= '  ';
			$j = 0;
		}
		$line .= (($j + 1) % 10) . ' ' x $spaces;
	}
	addstr($pad, $line);
	addstr($pad, sprintf "%6s ", 'load');
	clrtoeol($pad);
	move($pad, ++$y, $x = 0);
	
}

#
# This is used in _TopSleep to inform the user.
#
sub _PrintWarning {
	my ($message) = @_;
	attron($cmdwin, A_REVERSE);
	addstr($cmdwin, 0, 0, "$message");
	attroff($cmdwin, A_REVERSE);
	clrtoeol($cmdwin);
	refresh($cmdwin);
}

#
# Get input from user on commandline.
#
sub _GetString {
	
	my ($question) = @_;
	
	my $input = '';
	my $x = 0;
	
	#
	# Print question in terminal.
	#
	$question .= ' ';
	my $question_length = length($question);
	addstr($cmdwin, 0, 0, $question);
	$x = $question_length;
	clrtoeol($cmdwin);
	refresh($cmdwin);
	nodelay($cmdwin, 0);
	
	#
	# Get answer from user.
	#
	while (1) {
		my ($char, $key) = getch($cmdwin);
		next unless (defined($char));
		if ($char eq ERR) {
			# ERR returned on timeout.
			next;
		#
		# When your terminal is not configured correctly the backspace character may have a different ASCII number.
		# In most but not all cases this is then character number 127 (DEL). Preferably try to fix your terminal config, 
		# but if that does not help, switch the comment for the 2 lines below to treat char 127 as backspace.
		#
		#} elsif ($char eq KEY_BACKSPACE or $char eq "$CTRL_H" or $char eq "\cH" or ord($char) == 127) {
		} elsif ($char eq KEY_BACKSPACE or $char eq "$CTRL_H" or $char eq "\cH") {
			#
			# User corrected typo using backspace.
			#
			#_PrintWarning('DEBUG: KEY_BACKSPACE was pressed but it is mapped to ' . KEY_BACKSPACE);
			if (length($input) > 0) {
				$x--;
				move($cmdwin, 0, $x);
				delch($cmdwin);
				refresh($cmdwin);
				substr($input, $x - $question_length, 1, '');
			}
		} elsif ($char eq KEY_DC) {
			#
			# User corrected typo using delete.
			#
			if (length($input) > 0) {
				delch($cmdwin);
				refresh($cmdwin);
				substr($input, $x - $question_length, 1, '');
			}
		} elsif ($char eq $CTRL_G) {
			#
			# User aborted.
			#
			$input = "";
			last;
		} elsif ($char eq KEY_LEFT) {
			if ($x > $question_length) {
				$x--;
				move($cmdwin, 0, $x);
				refresh($cmdwin);
			}
		} elsif ($char eq KEY_RIGHT) {
			if ($x < $question_length + length($input)) {
				$x++;
				move($cmdwin, 0, $x);
				refresh($cmdwin);
			}
		} elsif ($char eq "\n") {
			#
			# User pressed return/enter.
			#
			last;
		} else {
			my $current_position_offset = $x - $question_length;
			substr($input, $current_position_offset, 0, $char);
			insch($cmdwin, $char);
			$x++;
			move($cmdwin, 0, $x);
			refresh($cmdwin);
		}
	}
	move($cmdwin, 0, 0);
	clrtoeol($cmdwin);
	refresh($cmdwin);
	return $input;
}

sub print_serverstatus_window {
	my $server = shift;
	_DestroySubWindow();
	_PrintWarning("TODO: This information is not available without perl-PBS");
	return;
	
	my $con = pbs_connect($server);
	if ($con <= 0) {
		_DestroySubWindow();
		_PrintWarning("Connect to $server failed: $PBS::pbs_errno\n");
		return;
	}
	my $ref = pbs_statserver($con, undef, undef);
	pbs_disconnect($con);
	_PrintSubWindow("$server", $ref->[0]->{attribs});
}

# since we don't store enough info about jobs in %jobs, go ahead and get
# it from the server
sub print_jobstatus_window {
	my $job    = shift;
	my $server = shift;
	_DestroySubWindow();
	_PrintWarning("TODO: This information is not available without perl-PBS");
	return;
	
	my $con = pbs_connect($server);
	if ($con <= 0) {
		_DestroySubWindow();
		_PrintWarning("Connect to $server failed: $PBS::pbs_errno\n");
		return;
	}
	
	my $ref = pbs_statjob($con, "$job.$server", undef, undef);
	pbs_disconnect($con);
	
	_PrintSubWindow("$job.$server", $ref->[0]->{attribs}, "'l' for node load report");

}

# We already have everything we need to know about nodes in our big Nodes struct,
# so just pull info from there.
sub print_nodestatus_window {
	my $nodename = shift or return;
	my $ref      = shift or return;
	
	my (@attrs, $name, $value);
	while (($name, $value) = each %{ $ref->{status} }) {
		push(@attrs, { name => $name, value => $value });
	}
	push(@attrs, { name => "ntype", value => $ref->{'ntype'} });
	push(@attrs, { name => "state", value => $ref->{'state'} });
	if (exists $ref->{properties}) {
		push(@attrs, { name => "properties", value => $ref->{properties} });
	}
	
	# TODO: only offer the 'j' option when only one job running, and not just on CPU0
	my $multiplejob = 0;
	foreach my $cpu (
		sort { $multiplejob ||= $ref->{job}{$a} != $ref->{job}{$b}; $a <=> $b }
		keys %{ $ref->{job} }
	  )
	{
		push(@attrs, { name => "CPU$cpu: job#", value => $ref->{job}{$cpu} });
	}
	
	#push(@attrs, { name => "multiple", value => $multiplejob });
	_PrintSubWindow("$nodename", \@attrs, "'j' for job details on CPU0");
	
}

#
# This is used by the subs above to actually paint the subpad.
#
#sub _PrintSubWindow {
#	
#	my ($title, $ref, $epilogue) = @_;
#	
#	my $line = 1;
#	
#	#
#	# Subwin's width is 8 fewer than the main win, and with 2 chars padding inside,
#	# each line will be 10 chars less wide than the main window.
#	# Select the smallest sizes from default and size currently in use
#	# to make sure the subpad is smaller than its parent pad.
#	# When the dimensions for the subpad are larger than those of the parent,
#	# subpad creating will fail!
#	#
#	my $subpad_width;
#	my $subpad_height;
#	if ($maxcolumns < $X) {
#		$subpad_width = $maxcolumns - 8;
#	} else {
#		$subpad_width = $X - 8;
#	}
#	if ($maxrows < $Y) {
#		$subpad_height = $maxrows - 5;
#	} else {
#		$subpad_height = $Y - 5;
#	}
#	
#	#
#	# TODO: Do we need to properly destroy the subpads?
#	#
#	$subpad = subpad($pad, $subpad_height, $subpad_width, 2, 5);
#	
#	$subpad or die "FATAL: Failed to _PrintSubWindow. X = $X | Y = $Y | maxcolumns = $maxcolumns | maxrows = $maxrows";
#	move($subpad, $line, 0);
#	clrtoeol($subpad);
#	move($subpad, $line, 2);
#	
#	foreach my $attr (@{$ref}) {
#		my $name       = $attr->{name};
#		my $value      = $attr->{value};
#		my $indent     = length($name) + 2 + 3;     # 2 for padding, 3 for " = "
#		my $maxlinelen = $subpad_width - $indent;
#		my $pattern    = ".{1,$maxlinelen}";
#		
#		addstr($subpad, $name . " = ");
#		my $string = $value;
#		
#		if ((length($string) + $indent) > $maxlinelen) {
#			while (length($string)) {
#				move($subpad, $line, $indent);
#				$string =~ s/($pattern)// or die "FATAL: Cannot truncate '$string' to max line length of $maxlinelen characters.";
#				addstr($subpad, "$1");
#				clrtoeol($subpad);
#				move($subpad, ++$line, 0);
#				clrtoeol($subpad);
#				move($subpad, $line, 2);
#			}
#			move($subpad, $line, 0);
#			clrtoeol($subpad);
#			move($subpad, $line, 2);
#		} else {
#			addstr($subpad, $string);
#			clrtoeol($subpad);
#			move($subpad, ++$line, 0);
#			clrtoeol($subpad);
#			move($subpad, $line, 2);
#		}
#	}
#	
#	move($subpad, ++$line, 0);
#	clrtoeol($subpad);
#	move($subpad, $line, 2);
#	if (defined $epilogue) {
#		addstr($subpad, "'q' to exit $epilogue");
#	} else {
#		addstr($subpad, "'q' to exit this window");
#	}
#	move($subpad, ++$line, 0);
#	clrtoeol($subpad);
#	
#	#
#	# Create a nice box by adding a border to the window.
#	#
#	resize($subpad, $line + 2, $X - 10);
#	attron($subpad, COLOR_PAIR(1));
#	box($subpad, &ACS_VLINE, &ACS_HLINE);
#	move($subpad, 0, 3);
#	addch($subpad, &ACS_RTEE);
#	addstr($subpad, "$title");
#	addch($subpad, &ACS_LTEE);
#	attroff($subpad, COLOR_PAIR(1));
#	
#	# currently not used (since the subwin is always smaller than the terminal)
#	$sub_Y = $line + 4;
#	$sub_X = $X - 10;
#
#}

sub _UpdateSubWindow {
	$subpad or return;
	#pnoutrefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
	pnoutrefresh($subpad_box, 0, 0, 0, 0, $sub_Y, $sub_X);
	pnoutrefresh($subpad_content, $sub_partial_y , $sub_partial_x, 2, 2, $sub_Y - 3, $sub_X - 3);
	#pnoutrefresh($subpad, 0, 0, 0, 0, $sub_Y - 1, $sub_X - 1);
	doupdate();
	#prefresh($subpad, 0, 0, 0, 0, $sub_Y, $sub_X);
}

sub _DestroySubWindow {
	delwin($subpad_content);
	delwin($subpad_box);
	delwin($subpad);
	$subpad         = 0;
	$subpad_box     = 0;
	$subpad_content = 0;
	$sub_partial_y  = 0;
	$sub_partial_x  = 0;
	$sub_Y  = 0;
	$sub_X  = 0;
	if ($partial_y >= $last_y - $Y + 2) {
		$partial_y = $last_y - $Y + 3;
		pnoutrefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
	}
}

sub _PrintHelpPad {
	
	my $title = 'Settings & Help';
	my $line = 1;
	my $color_pair = 3;
	my $indent = '  ';
	
	#
	# Get dimensions for subpads.
	#
	# When the dimensions for the subpad are larger than those of the parent,
	# subpad creating will fail!
	#
	my $sub_width;
	my $sub_height;
	my $box_width;
	my $box_height;
	my $content_width   = 100;
	my $content_height  = 63;
	
	if ($maxcolumns < $X) {
		$box_width = $maxcolumns;
	} else {
		$box_width = $X;
	}
	if ($maxrows < $Y) {
		$box_height = $maxrows;
	} else {
		$box_height = $Y - 1;
	}
	
	if ($content_width + 2 < $box_width) {
		$sub_width = $box_width;
	} else {
		$sub_width = $content_width + 2;
	}
	if ($content_height + 2 < $box_height) {
		$sub_height = $box_height;
	} else {
		$sub_height = $content_height + 2;
	}
	$sub_Y = $box_height;
	$sub_X = $box_width;
	$sub_last_y = $content_height;
	$sub_last_x = $content_width;
	
	#
	# Create subpads.
	#
	$subpad         = newpad($sub_height, $sub_width);
	$subpad_box     = newpad($box_height, $box_width);
	$subpad_content = subpad($subpad, $content_height, $content_width , 2, 2);
	$subpad         or die "FATAL: Failed to create subpad in _PrintHelpPad. X = $X | Y = $Y | sub_height = $sub_height | sub_width = $sub_width";
	$subpad_box     or die "FATAL: Failed to create subpad_box in _PrintHelpPad. X = $X | Y = $Y | sub_height = $sub_height | sub_width = $sub_width | box_height = $box_height | box_width = $box_width";
	$subpad_content or die "FATAL: Failed to create subpad_content in _PrintHelpPad. X = $X | Y = $Y | sub_height = $sub_height | sub_width = $sub_width | con_height = $content_height | con_width = $content_width";
	clrtobot($subpad);
	clrtobot($subpad_content);
	clrtobot($subpad_box);
	
	#
	# Create a nice box by adding a border to the window.
	#
	attron($subpad_box, COLOR_PAIR($color_pair) | A_BOLD);
	box($subpad_box, &ACS_VLINE, &ACS_HLINE);
	move($subpad_box, 0, 3);
	addch($subpad_box, &ACS_RTEE);
	attron($subpad_box, A_REVERSE);
	addstr($subpad_box, " $title ");
	attroff($subpad_box, A_REVERSE);
	addch($subpad_box, &ACS_LTEE);
	attroff($subpad_box, COLOR_PAIR($color_pair) | A_BOLD);
	
	#
	# Add content to the window.
	#
	addstr($subpad_content, 'Current settings:');
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Version ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $VERSION);
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Refresh ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $sleeptime . ' seconds');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Grid width ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $columns . ' cores');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Colorization ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $colorize ? 'on' : 'off');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	if ($colorize) {
		addstr($subpad_content, $indent . 'Color by ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, $color_by);
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
	}
	addstr($subpad_content, $indent . 'State summary display ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $show_summary ? 'on' : 'off');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Grid display ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $show_grid ? 'on' : 'off');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Display jobs in grid ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $show_jobs ? 'on' : 'off');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Load = ');
	attron($subpad_content, A_BOLD | COLOR_PAIR(2)) if ($colorize);
	addstr($subpad_content, 'Ok');
	attroff($subpad_content, A_BOLD | COLOR_PAIR(2)) if ($colorize);
	addstr($subpad_content, '        indicates ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, 'requested cores - ' . $healthy_load_stdev . ' <= load <= requested cores + ' . $healthy_load_stdev);
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Load = ');
	attron($subpad_content, A_BOLD | COLOR_PAIR(3)) if ($colorize);
	addstr($subpad_content, 'too low!');
	attroff($subpad_content, A_BOLD | COLOR_PAIR(3)) if ($colorize);
	addstr($subpad_content, '  indicates ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, 'load < requested cores - ' . $healthy_load_stdev);
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Load = ');
	attron($subpad_content, A_BOLD | COLOR_PAIR(1)) if ($colorize);
	addstr($subpad_content, 'TOO HIGH!');
	attroff($subpad_content, A_BOLD | COLOR_PAIR(1)) if ($colorize);
	addstr($subpad_content, ' indicates ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, 'load > requested cores + ' . $healthy_load_stdev);
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Showing jobs from: ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, join(" ", @host));
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Queue display ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $show_queue ? 'on' : 'off');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Show queued jobs ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, $show_qqueue ? 'on' : 'off');
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	if ($colorize) {
		addstr($subpad_content, $indent . 'CPU/Mem ');
		attron($subpad_content, A_BOLD | COLOR_PAIR(2));
		addstr($subpad_content, 'healthy resource usage ');
		attroff($subpad_content, A_BOLD | COLOR_PAIR(2));
		addstr($subpad_content, ' indicates ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, $res_usage_low . ' <= (used / requested) <= ' . $res_usage_high);
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
		
		addstr($subpad_content, $indent . 'CPU/Mem ');
		attron($subpad_content, A_BOLD | COLOR_PAIR(3)) if ($colorize);
		addstr($subpad_content, 'inefficiently low usage');
		attroff($subpad_content, A_BOLD | COLOR_PAIR(3)) if ($colorize);
		addstr($subpad_content, ' indicates ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, '(used / requested) < ' . $res_usage_low);
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
		
		addstr($subpad_content, $indent . 'CPU/Mem ');
		attron($subpad_content, A_BOLD | COLOR_PAIR(1)) if ($colorize);
		addstr($subpad_content, 'dangerously high usage ');
		attroff($subpad_content, A_BOLD | COLOR_PAIR(1)) if ($colorize);
		addstr($subpad_content, ' indicates ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, '(used / requested) > ' . $res_usage_high);
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
	}
	addstr($subpad_content, $indent . 'Number of possible colors ');
	attron($subpad_content, A_BOLD);
	addstr($subpad_content, "$COLOR_PAIRS\n");
	attroff($subpad_content, A_BOLD);
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	if ($show_user) {
		addstr($subpad_content, $indent . 'Limiting job view to user(s) ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, "$show_user\n");
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
	}
	if ($show_node) {
		addstr($subpad_content, $indent . 'Limiting job view to node(s) ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, "$show_node\n");
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
	}
	if ($show_job_id && $show_job_id ne '!') {
		my @jobs_selected = split(' ', $show_job_id);
		my $job_count = scalar(@jobs_selected);
		addstr($subpad_content, $indent . 'Limiting job view to ');
		attron($subpad_content, A_BOLD);
		addstr($subpad_content, $job_count . ' job(s) from search result.' . "\n");
		attroff($subpad_content, A_BOLD);
		
		clrtoeol($subpad_content);
		move($subpad_content, ++$line, 0);
	}
	
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, 'Navigation:');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Press [Arrow], [Page Up], [Page Down], [Home] or [End] keys to navigate.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);

	addstr($subpad_content, $indent . $indent . 'Depending on your terminal settings you may have to press ');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	addstr($subpad_content, $indent . $indent . 'a modifier key ([Alt], [Ctrl] or [Shift]) + a navigation key to scroll.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);

	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, 'Interactive commands are:');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '[space] Update Display.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'q       Quit.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'h       Print this Help.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'c       Color cores in grid display by job, user, queue or resource usage.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'u       Show only jobs for a subset of Users.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts comma seprated list for multiple users.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'n       Show only jobs for a subset of Nodes.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts comma separated list for multiple nodes (e.g. 02,05,10).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts dash separated range of node (e.g. 02-07).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 's       Seconds to refresh.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 't       Toggle display of "waiting" jobs in the queue display.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Waiting jobs include jobs with job states:');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '              H: Job is held due to unsatisfied dependency.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '              Q: Job is queued, eligible to run or routed.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '              W: Job is waiting for its execution start time (-a option) to be reached.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '              S: Job is suspended.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Active jobs include jobs with job states:');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '              T: Job is being transferred to a node.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '              R: Job is running on a node.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '              E: Job is exiting after having run on a node.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '              C: Job is completed.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'j       Toggle display of Jobs in grid display.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'w       With of grid display in number of cores.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '/       Search jobs and display details. Search is not case sensitive.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts i: prefix to limit search to job IDs (e.g. i:251).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts j: prefix to limit search to job names (e.g. j:MyExperiment).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts n: prefix to limit search to jobs running on a node (e.g. n:3).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts s: prefix to limit search to jobs from a server (e.g. s:scheduler02).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts u: prefix to limit search to jobs from certain users (e.g. u:myaccount).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . '           Accepts q: prefix to limit search to jobs submitted to certain queue (e.g. q:test).');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'C       Toggle Colorization.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'S       Toggle State summary.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'G       Toggle Grid display.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	addstr($subpad_content, $indent . 'Q       Toggle Queue display.');
	clrtoeol($subpad_content);
	move($subpad_content, ++$line, 0);
	
	if ($content_height != $line) {
		_PrintWarning('WARN: window size not calculated correctly. content_height is ' . $content_height . ', but we counted ' . $line . ' lines.');
	}
	
	_UpdateSubWindow(@_);
	
	_PrintWarning('Press any non-navigation key to exit this ' . $title . ' window...');
	
	#
	# Wait for the user to hit the any key.
	#
	#cbreak;
	#nodelay($helpwin, 0);
	#getch($helpwin);
	#halfdelay(1);
	#prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
	#move($cmdwin, 0, 0);
	#clrtoeol($cmdwin);
	#refresh($cmdwin);
	#delwin($helpwin);
	
}

sub _PerformSearch {
	
	my ($search_pattern, $jobs) = @_;
	my @job_ids_found;
	my $object_type;
	
	#
	# Did the user disable the filtering by providing an empty search pattern of searching for '.*'?
	#
	if ((!defined($search_pattern)) or $search_pattern =~ m/^\n*$/) {
		$show_job_id = 0;
		_PrintWarning('INFO: disabled search; showing all jobs.');
		return;
	} elsif ($search_pattern =~ s/^([a-z])://) {
		#
		# Did the user specify an object type to limit the search?
		#
		if ($1 eq 'i') {
			$object_type = 'JobID';
		} elsif ($1 eq 'j') {
			$object_type = 'JobName';
		} elsif ($1 eq 'n') {
			$object_type = 'Node';
		} elsif ($1 eq 's') {
			$object_type = 'Server';
		} elsif ($1 eq 'u') {
			$object_type = 'User';
		} elsif ($1 eq 'q') {
			$object_type = 'Queue';
		} else {
			_PrintWarning('ERROR: Invalid search pattern prefix.');
			return;
		}
	} else {
		$object_type = 'Any';
	}
	
	#
	# Reset job ID filter -> show nothing.
	#
	$show_job_id = '';
	
	#
	# Search for relevant objects in the data structure for all jobs and all nodes.
	#
	foreach my $job (keys(%{$jobs})) {
		my $found = 0;
		my $job_name = ${$jobs}{$job}{'jname'};
		my $user     = ${$jobs}{$job}{'user'};
		my $queue    = ${$jobs}{$job}{'queue'};
		if ($object_type eq 'JobID' || $object_type eq 'Any') {
			my $job_id_pattern = $search_pattern;
			my $server;
			if ($search_pattern =~ m/^(.+)\.[^\+\*\?\.]+$/) {
				$job_id_pattern = $1;
				$server = $2;
			}
			if ($job =~ m/$job_id_pattern/i and (!defined($server) or ${$jobs}{$job}{'server'} =~ m/$server/)) {
				$found = 1;
			}
		}
		if ($object_type eq 'JobName' || $object_type eq 'Any') {
			if ($job_name =~ m/$search_pattern/i) {
				$found = 1;
			}
		}
		if ($object_type eq 'Node' || $object_type eq 'Any') {
			if (defined(${$jobs}{$job}{'node'})) {
				my $node_pattern = $search_pattern;
				my $server;
				if ($search_pattern =~ m/^(.+)\.[^\+\*\?\.]+$/) {
					$node_pattern = $1;
					$server = $2;
				}
				if (${$jobs}{$job}{'node'} =~ m/$node_pattern/i and (!defined($server) or ${$jobs}{$job}{'server'} =~ m/$server/)) {
					$found = 1;
				}
			}
		}
		if ($object_type eq 'Server' || $object_type eq 'Any') {
			if (${$jobs}{$job}{'server'} =~ m/$search_pattern/i) {
				$found = 1;
			}
		}
		if ($object_type eq 'User' || $object_type eq 'Any') {
			if ($user =~ m/$search_pattern/i) {
				$found = 1;
			}
		}
		if ($object_type eq 'Queue' || $object_type eq 'Any') {
			if ($queue =~ m/$search_pattern/i) {
				$found = 1;
			}
		}
		
		if ($found) {
			push (@job_ids_found, $job);
		}
	}
	
	#
	# Create space separated list of job IDs for the matching jobs 
	# that will be diplayed on referesh of the display.
	#
	foreach my $job (@job_ids_found) {
		$show_job_id   .= $job . ' ';
	}
	$show_job_id   =~ s/ $//;
	
	#
	# Check if we found anything.
	#
	my $jobs_found = scalar(@job_ids_found);
	if ($jobs_found < 1) {
		$show_job_id = '!';
		_PrintWarning('WARN: No objects found matching ' . $search_pattern);
	} else {
		_PrintWarning('INFO: found ' . $jobs_found . ' job(s) matching ' . $search_pattern);
	}
	
}

#
# Loop around processing user input until the timer expires 
# and it is time to return back up to _MainLoop() for an update.
#
sub _TopSleep {
	
	my $targettime = time() + $sleeptime;
	
	while (time() < $targettime) {
		halfdelay(1);
		my $input = getch($cmdwin);
		if ($SIGWINCH) {
			$SIGWINCH = 0;
			endwin;
			refresh();
			_UpdateDisplay(@_);
		}
		if (defined($input)) {
			if ($input eq KEY_HOME or $input eq KEY_SHOME or $input eq KEY_FIND) {
				if ($subpad) {
					$sub_partial_y = 0;
					$sub_partial_x = 0;
					_UpdateSubWindow();
				} else {
					$partial_y = 0;
					$partial_x = 0;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq KEY_END or $input eq KEY_SEND or $input eq KEY_SELECT) {
				if ($subpad) {
					$sub_partial_y = $sub_last_y + 4 - $sub_Y;
					$sub_partial_x = 0;
					_UpdateSubWindow();
				} else {
					$partial_y = $last_y + 2 - $Y;
					$partial_x = 0;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq KEY_PPAGE or $input eq KEY_SPREVIOUS or $input eq $CTRL_B) {
				if ($subpad) {
					$sub_partial_y -= $sub_Y - 4;
					$sub_partial_y <= 0 and $sub_partial_y = 0;
					_UpdateSubWindow();
				} else {
					$partial_y -= $Y - 2;
					$partial_y <= 0 and $partial_y = 0;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq KEY_NPAGE or $input eq KEY_SNEXT or $input eq $CTRL_F) {
				if ($subpad_box) {
					$sub_partial_y += $sub_Y - 4;
					$sub_partial_y >= $sub_last_y - $sub_Y + 4 and $sub_partial_y = $sub_last_y - $sub_Y + 4;
					_UpdateSubWindow();
				} else {
					$partial_y += $Y - 2;
					$partial_y >= $last_y - $Y + 2 and $partial_y = $last_y - $Y + 2;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq '8' or $input eq KEY_UP) {
				if ($subpad) {
					$sub_partial_y <= 0 and $sub_partial_y = 0, next;
					$sub_partial_y--;
					_UpdateSubWindow();
				} else {
					$partial_y <= 0 and $partial_y = 0, next;
					$partial_y--;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq '2' or $input eq KEY_DOWN) {
				if ($subpad) {
					$sub_partial_y >= $sub_last_y - $sub_Y + 4 and next;
					$sub_partial_y++;
					_UpdateSubWindow();
				} else {
					$partial_y >= $last_y - $Y + 2 and next;
					$partial_y++;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq '4' or $input eq KEY_LEFT) {
				if ($subpad) {
					$sub_partial_x <= 0 and $partial_x = 0, next;
					$sub_partial_x--;
					_UpdateSubWindow();
				} else {
					$partial_x <= 0 and $partial_x = 0, next;
					$partial_x--;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($input eq '6' or $input eq KEY_RIGHT) {
				if ($subpad) {
					$sub_partial_x >= $sub_last_x - $sub_X and next;
					$sub_partial_x++;
					_UpdateSubWindow();
				} else {
					$partial_x >= $last_x - $X and next;
					$partial_x++;
					prefresh($pad, $partial_y, $partial_x, 0, 0, $Y - 2, $X - 1);
				}
			} elsif ($subpad && $input ne '-1') {
				#
				# User pressed the "any" key to close a sub window...
				#
				_DestroySubWindow();
				_UpdateDisplay(@_);
				clear($cmdwin);
				move($cmdwin, 0, 0);
				refresh($cmdwin);
				#_PrintWarning('DEBUG: input was: ' . $input . '.');
			} elsif ($input eq 'q') {
				endwin;
				exit(0);
			} elsif ($input eq $CTRL_L) {
				# Why doesn't curses do this automatically?
				clear($pad);
				clrtoeol($cmdwin);
				_UpdateDisplay(@_);
			} elsif ($input eq 'h' || $input eq '?') {
				_PrintHelpPad();
#			} elsif ($input =~ /^\d$/) {
#				# Change the visible CPUs.
#				# TODO: Don't allow the user to display CPUs that don't exist on any node.
#				# TDOD: Currently disabled as we have only one (virtual) CPU with many cores.
#				if (grep /^$input$/, @show_cpu) {
#					@show_cpu = grep !/$input$/, @show_cpu;
#				} else {
#					my %seen = ();
#					foreach (@show_cpu, $input) {
#						$seen{$_} = 1;
#					}
#					@show_cpu = sort keys %seen;
#				}
#				_UpdateDisplay(@_);
			} elsif ($input eq 's') {
				if ($subpad) {
					_DestroySubWindow();
					_UpdateDisplay(@_);
					return;
				}
				$input = _GetString('Number of seconds for refresh? ' . "[$sleeptime] ");
				if ($input =~ m/^\d+$/ && $input >= 1) {
					$sleeptime = $input;
					$targettime = time() + $sleeptime;
				} else {
					_PrintWarning('ERROR: Invalid number!');
				}
			} elsif ($input eq 'w') {
				$input = _GetString('Width of grid display in number of cores ? ' . "[$columns] ");
				if ($input) {
					if ($input =~ /^\d+$/ and $input > 0) {
						$columns = $input;
						_UpdateDisplay(@_);
					} else {
						_PrintWarning('ERROR: Invalid number!');
					}
				}
			} elsif ($input eq 'u') {
				$input = _GetString('Limit view to "a" for all, "me" for the current user, or comma separated list of users? ');
				if ($input) {
					if ($input eq 'all' or $input eq 'a') {
						$show_user = 0;
					} elsif ($input eq 'me' or $input eq 'm') {
						$show_user = $ENV{USER};
					} elsif ($input =~ /^\+(.*)/) {
						if ($show_user eq '0') {
							_PrintWarning('ERROR: Cannot add user to list of users. Please specify a list first.');
							return;
						}
						if ($1 eq 'me' or $1 eq 'm') {
							$show_user .= ' ' . $ENV{USER};
						} else {
							$show_user .= " $1";
						}
						$show_user =~ s/^ / /g;
					} elsif ($input =~ /^-(.*)/) {
						if ($show_user eq '0') {
							_PrintWarning('ERROR: Cannot remove user from list of users. Please specify a list first.');
							return;
						}
						if ($1 eq 'me' or $1 eq 'm') {
							$show_user =~ s/\b$ENV{USER}\b//;
						} else {
							$show_user =~ s/\b$1\b//;
						}
						$show_user =~ s/  / /g;
						$show_user =~ s/^ / /g;
						$show_user =~ s/ $/ /g;
					} else {
						$show_user = $input;
					}
					_UpdateDisplay(@_);
				}
			} elsif ($input eq 'n') {
				$input = _GetString('Limit view to "a" for all nodes, range or comma separated list of nodes? ');
				if ($input) {
					if ($input eq 'all' or $input eq 'a') {
						$show_node = 0;
					} elsif ($input =~ m/^\+(.*)/) {
						if ($show_node eq '0') {
							_PrintWarning('ERROR: Cannot add node to list of nodes. Please specify a list first.');
							return;
						}
						$show_node .= " $1";
						$show_node =~ s/^ / /g;
					} elsif ($input =~ m/^-(.*)/) {
						if ($show_node eq '0') {
							_PrintWarning('ERROR: Cannot remove node from list of nodes. Please specify a list first.');
							return;
						}
						$show_node =~ s/\b$1\b//;
						$show_node =~ s/  / /g;
						$show_node =~ s/^ / /g;
						$show_node =~ s/ $/ /g;
					} elsif ($input =~ m/^([0-9]+)-([0-9]+)$/) {
						$show_node = join(' ', $1 .. $2);
					} else {
						$show_node = $input;
					}
					_UpdateDisplay(@_);
				}
			} elsif ($input eq 'c') {
				if (!has_colors()) {
					_PrintWarning('ERROR: Terminal doesn\'t support colors.');
					$colorize = 0;
				} else {
					# Toggle colorize if color was disabled.
					$colorize = !$colorize unless ($colorize);
					# Get item type to group by for coloring nodes in grid display 
					$input = _GetString('Color jobs by "j" (job), "u" (user), "q" (queue) or "r" (resource usage)? ' . "[$color_by]");
					if ($input) {
						if ($input eq 'job' or $input eq 'j') {
							$color_by = 'job';
						} elsif ($input eq 'user' or $input eq 'u') {
							$color_by = 'user';
						} elsif ($input eq 'queue' or $input eq 'q') {
							$color_by = 'queue';
						} elsif ($input eq 'resource usage' or $input eq 'r') {
							$color_by = 'resources';
						} else {
							_PrintWarning('ERROR: Unsupported color by value.');
						}
						_UpdateDisplay(@_);
					}
				}
			} elsif ($input eq 'C') {
				$colorize = !$colorize;
				if ($colorize && !has_colors()) {
					_PrintWarning('ERROR: Terminal doesn\'t support colors.');
					$colorize = 0;
				}
				_UpdateDisplay(@_);
			} elsif ($input eq 'S') {
				$show_summary = !$show_summary;
				_UpdateDisplay(@_);
			} elsif ($input eq 'G') {
				$show_grid = !$show_grid;
				_UpdateDisplay(@_);
			} elsif ($input eq 'Q') {
				$show_queue = !$show_queue;
				_UpdateDisplay(@_);
			} elsif ($input eq 't') {
				$show_qqueue = !$show_qqueue;
				_UpdateDisplay(@_);
			} elsif ($input eq 'j') {
				$show_jobs = !$show_jobs;
				_UpdateDisplay(@_);
			} elsif ($input eq ' ') {
				addstr($cmdwin, 0, 0, "Updating...");
				clrtoeol($cmdwin);
				refresh($cmdwin);
				move($cmdwin, 0, 0);
				clrtoeol($cmdwin);
				return;
			} elsif ($input eq '/') {
				$input = _GetString('Search string? ');
				_PerformSearch($input, $_[3]);
				_UpdateDisplay(@_);
			} elsif ($input =~ m/^\n$/) {
				#
				# User pressed the enter key.
				# Most likely to get rid of an error/warning message.
				# Just update the screen.
				#
				addstr($cmdwin, 0, 0, '');
				clrtoeol($cmdwin);
				refresh($cmdwin);
				move($cmdwin, 0, 0);
				clrtoeol($cmdwin);
				#return;
			} elsif ($input =~ m/[^\d\.-]/) {
				_PrintWarning('ERROR: unsupported command ' . $input . '.');
				return;
			}
			#_PrintWarning("DEBUG: y = $y | x = $x | Y = $Y | X = $X | p_y = $partial_y | p_x = $partial_x | l_y = $last_y | l_x = $last_x | sub_Y = $sub_Y | sub_X = $sub_X | s_p_y = $sub_partial_y | s_p_x = $sub_partial_x.");
		}
	}
}

sub _LoadConfig {
	my ($config_file) = @_ or return;
	return unless (-f $config_file);
	
	open(F, $config_file) or die "$config_file: $!\n";
	while ($_ = <F>) {
		chomp;
		s/#.*//;
		next unless $_;
		my ($name, $value) = split(/=/);
		$name  =~ s/\s//g;
		$value =~ s/\s//g;
		next if (length($name) <= 0 or length($value) <= 0);
		
		#
		# TODO: security risk: get rid of eval.
		#
		if ($name eq "host" or $name eq "show_cpu") {
			eval "\@$name=(\"" . join('","', split(',', $value)) . "\")";
		} elsif ($name eq "show_user") {
			eval "\$$name=join(' ', split(',', \"$value\"))";
		} else {
			eval "\$$name=$value";
		}
	}
	close(F);
}

__END__

=head1 NAME

ctop - cluster monitoring utility for OpenPBS or Torque

=head1 SYNOPSIS

ctop [OPTION]... [@hostname]...

=head1 DESCRIPTION

Draws a full-terminal display of your nodes and jobs.  The default grid
shows each node's 1st CPU as a single character.  The specific character
denotes the state of the node or identifies the job running on that CPU.  The
job listing shows the job name, queue name, state, etc. and, on the far left,
the character used to identify nodes in the upper grid.  Pressing a number key
will toggle the display of that CPU on all of the nodes.

This program runs best if the C<perl-PBS> module is installed.  While there are
currently no loss of features if it isn't installed, it will run much faster
with it.  If you are unsure if PBS is installed, run this program, hit C<h>, and
look for the B<Backend> information at the top right.

=head1 COMMAND-LINE OPTIONS

=over 4

=item   B<-s> num

seconds between refreshes

=item   B<-w> num

number of columns to display in the grid

=item   B<-u>

usernames for limiting the view of the grid and job list.  Can be a
comma-seperated list of usernames or C<all>.  C<me> is a pseudonym for the
username running ctop(1).

=item   B<-C>

toggle colorization

=item   B<-S>

toggle state summary display

=item   B<-G>

toggle grid display

=item   B<-Q>

toggle queue display

=item   B<-t>

toggle showing queued jobs in queue display

=item   B<-[0-9]...>

cpu numbers for grid display

=item   B<-J>

toggle jobs in grid display

=item   B<-V>

print version and exit

=back

=head1 INTERACTIVE COMMANDS

Several single-key commands are recognized while ctop(1) is running.  The
arrow keys, PageUp, and PageDown keys will scroll the display if it doesn't fit
in your terminal.

When prompted to type something, ctrl-g can be used to cancel the command.

=over 4

=item   B<space>

Immediately update display

=item B<q>

Quit ctop(1)

=item B<h>

Display help screen, version, and current settings

=item B<c>

Prompts for the number of columns to display the node grid

=item B<s>

Prompts for the number of seconds to wait between display updates

=item B<u>

Prompts for a username.  The grid and job listing will be limited to the named
user.  Input C<all> will remove all limitations (the default), and C<me> will
limit to the current username running ctop(1).  If the username or C<me> is
prefixed with a C<+> or C<->, the username will be added or removed from the
list of usernames to be limited.  C<a> and C<m> are shortcuts for C<all> and
C<me>.

=item B</>

Prompts the user for a search string, for displaying the details of.  The
search can optionally begin with one of the following pattern specifiers
(think: mutt): C<~s> for a server, C<~n> for a node, or C<~j> for a job number.
If no pattern specifier is found, ctop will attempt to find the object that
best matches the search string. The string can be a server name, nodename, or a
job number.  Nodenames can optionally be followed by a space and the server
name.  Job numbers may optionally be followed by a dot and the server name.

If an object is found, a subwindow will be opened displaying details.  Hit C<q>
to exit the window.

When viewing a job detail subwindow, pressing C<l> is a shortcut for jumping
directly to the associated job's node load subwindow.

(Mnemonic: like using / to search for text in vi or less)

=item B<l>

Prompts the user for a job id.  A B<node load report> subwindow will be
displayed for the given jobid.  This subwindow shows the current load average,
the physical and available memory, and the number of sessions.  Available
physical memory will be negative in the event of swapping.  If the number of
sessions is 0, that might indicate a problem on that node.

Pressing C<l> in this subwindow jumps you directly to the associated job detail
subwindow; as if the user typed C</jobid>.

(Mnemonic: load average)

=item B<C>

Toggle the use of the colors in the display

=item B<S>

Toggle the display of the state summary

=item B<G>

Toggle the display of the node grid

=item B<Q>

Toggle the display of the job queue

=item B<t>

Toggle the display of currently queued (not running) jobs in the display.  This
can reduce the size of the queue display considerably in some environments.

(Mnemonic: I don't know, toggle?  C<Q> was already used for something more important)

=item B<J>

Toggle the display of job letters in the node grid.  This handy because you can
see the node state "hidden" behind the job letter.  For example, use this to
see which nodes are not yet "busy" that have jobs.

=for comment
# SMP stuff disabled in current version:
#= item B<Any single number (0-9)>
#
#Toggle display of that CPU number in the display.  This is confusing at first,
#but useful in SMP environments (See SMP section below).
#

=back

=head1 STARTUP

ctop(1) has many configuration variables that can set on the command line,
interactively, or from configuration files.  When ctop(1) starts, it first
initializes these variables with built-in defaults, then reads in
F</etc/ctoprc>, the reads F<~/.ctoprc>, and finally parses the command line
arguments.  Note that several of the command line arguments and interactive
commands are toggles, they don't directly set the value of the configuration.
In contrast, the configuration files are not toggles.

The configuration files may contain following name=value pairs:

=over 4

=item B<columns>

Number of columns in the node grid, positive integer

=item B<sleeptime>

Number of seconds to pause between display updates, positive integer

=item B<colorize>

Use colors in the display, 1 or 0

=item B<show_summary>

Display the summary at the top of the display, 1 or 0

=item B<show_grid>

Show the node grid, 1 or 0

=item B<show_queue>

Show the job queue, 1 or 0

=item B<show_qqueue>

Show queued (not running) jobs in the queue display, 1 or 0

=item B<show_jobs>

Show job and color information in the node grid, 1 or 0

=for comment
# SMP stuff disabled in current version:
#=item B<show_cpu>
#
#Comma seperated list of CPU numbers to display
#
=item B<show_user>

Usernames to limit the view in the grid and job list.  Can be a comma-seperated
list of users, C<all>, or C<me>.

It might be reasonable for a site to have C<show_user=me> in F</etc/ctoprc>
and for admin users to have C<show_user=all> in their own F<~/.ctoprc>.

Members of a group might want all of their teammate's usernames in their own
F<~/.ctoprc>.

=item B<host>

Comma seperated list of hostnames running pbs_server

=item B<maxrows>

Number of rows in the large scrollable panel

=item B<maxcolums>

Number of columns in the large scollable panel

=item B<maxnodegrid>

Nodes with more than this number of CPUs will be represented by a seperate grid

=back

A sample configuration file:

    # I'm grumpy and don't like color
    colorize=0

    # my 6 CPU machine should get a seperate grid
    maxnodegrid=5

    # all of my Torque servers
    host=teraserver,bigbird,testhpc

=head1 SMP ENVIRONMENTS

ctop(1) was developed with three specific clusters in mind, these are a 1000
node cluster of dual SMP machines, a 64 proc SMP with 16 single node machines,
and a 21 node cluster of single procs without nicely numbered hostnames.  With
this kind of pedigree, ctop(1) is fairly flexible.

By default, the node grid will show the state of the first CPU of 30 nodes in
each row.  The number of columns in the grid can be shrunk or expanded on the
command line with C<-C>, or interactively with C<c>.  Additional CPUs can be
displayed by pressing the appropriate number key.  Using the number keys is
confusing at first, but if you try it a few times it will became natural.
By default, nodes with 8 or more CPUs are displayed in a seperate grid.

The first two clusters mentioned above display well with the defaults.  The
third is typically displayed with the number of columns set to "1".

=head1 FILES

=over 4

=item F</etc/ctoprc>

The global configuration file  

=item F<~/.ctoprc>

The personal configuration file.

=back

=head1 ENVIRONMENTAL VARIABLES

=over 4

=item PBS_DEFAULT  

The server's hostname (same as most PBS client commands)

=back

=head1 SEE ALSO

=over 4

=item PBS(3pm), qstat(1B)

=back

=head1 BUGS

The large Job structure uses the servername supplied by the user, the Job
structure uses the servername returned by the server... so they don't match up
(this makes the jobloadreport imprecise).  
The curses code is very ineffecient, the screen flickers too much.
grep FIXME from ctop for more!

=head1 AUTHOR

ctop(1) was originally written by Garrick Staples E<lt>garrick@usc.eduE<gt>.
The node grid and lettering concept is from Dennis Smith.  Thanks to Egan Ford
and the xCAT mailing list for testing and feedback.

